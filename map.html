<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>GPX & ì‚¬ì§„ ì§€ë„ (v5)</title>
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=94bf4516825c146467eb2318cd55b782&libraries=services"></script>
  <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; }
    #map { width:100%; height:100%; }
    #search-form, #address-display, .controls, #myLocationBtn {
      position:absolute; background:white; padding:5px; border-radius:5px; box-shadow:0 2px 6px rgba(0,0,0,0.3); z-index:1000;
    }
    #search-form { top:10px; left:10px; display:flex; gap:5px; }
    #address-display { top:10px; left:260px; background:rgba(0,0,0,0.6); color:white; font-size:12px; white-space:nowrap; overflow:hidden; }
    .controls { top:10px; right:10px; display:flex; gap:6px; }
    #myLocationBtn { bottom:20px; right:20px; border-radius:50%; }
.dotOverlay.distanceInfo {
  background: white;
  border: 1px solid #db4040;
  padding: 5px;
  border-radius: 3px;
  font-size: 12px;
  white-space: nowrap;
}
.drawing-cursor * {
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><text x="0" y="20" font-size="20" fill="red">&#x3009;</text></svg>') 0 0, auto !important;
}

  </style>
</head>
<body>
  <form id="search-form">
    <input id="address-input" type="text" placeholder="ì£¼ì†Œ ê²€ìƒ‰" style="padding:5px; width:180px;">
    <button type="submit" style="padding:5px;">ê²€ìƒ‰</button>
  </form>
  <div id="address-display">ì£¼ì†Œ ì—†ìŒ</div>
  <div id="myLocationBtn" title="ë‚´ ìœ„ì¹˜ë¡œ ì´ë™">ğŸ“</div>
  <div class="controls">
    <label>ìœ„ë„:</label><input id="latitude" readonly size="12">
    <label>ê²½ë„:</label><input id="longitude" readonly size="12">
    <button type="button" onclick="downloadAllPhotos()">ğŸ“¸ ì‚¬ì§„ ë‹¤ìš´ë¡œë“œ</button>
    <button type="button" onclick="copyCoordinates()">ë³µì‚¬ (Ctrl+C)</button>
    <button type="button" onclick="startDrawing()">ì„  ê·¸ë¦¬ê¸° (Alt)</button>
    <button type="button" onclick="resetPolylines()">ì„  ì´ˆê¸°í™”</button>
    <button type="button" onclick="resetAll()">í™”ë©´ ì´ˆê¸°í™”</button>
    <button type="button" onclick="exportGPX()">GPX ë‚´ë³´ë‚´ê¸°</button>
  </div>
  <div id="map"></div>

<script src="https://cdn.jsdelivr.net/npm/piexifjs"></script>
<script>
let map, geocoder, drawingMode = false;
let markers = [], polylines = [], markerInputOverlay = null;
let currentPolyline, currentPath = [];
let searchMarker = null;
let movingPhotoMarker = null;
let isDragging = false;  // ë“œë˜ê·¸ ì¤‘ ì—¬ë¶€
// START: ê±°ë¦¬ í‘œì‹œìš© ì „ì—­ë³€ìˆ˜
let moveLine = null;
let distanceOverlay = null;

function getRandomColor() {
  return `#${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;
}

function attachMarkerFollower(marker, followers = []) {
  kakao.maps.event.addListener(marker, 'position_changed', () => {
    const pos = marker.getPosition();
    followers.forEach(obj => {
      if (typeof obj.setPosition === 'function') {
        obj.setPosition(pos);
      }
    });
  });
}

function updateDistance(mouseEvent) {
  if (!drawingMode || currentPath.length === 0) return;

  const lastPos = currentPath[currentPath.length - 1];
  const mousePosition = mouseEvent.latLng;
  const movepath = [lastPos, mousePosition];

  if (!moveLine) {
    moveLine = new kakao.maps.Polyline({
      strokeWeight: 3,
      strokeColor: '#db4040',
      strokeOpacity: 0.5,
      strokeStyle: 'solid'
    });
  }
  moveLine.setPath(movepath);
  moveLine.setMap(map);

  const totalDistance = currentPolyline.getLength() + moveLine.getLength();

  const formatDistance = d => {
    if (d <= 1000) return `${d.toFixed(1)}m`;
    return `${(d / 1000).toFixed(2)}km`;
  };

  const content = `
    <div class="dotOverlay distanceInfo" style="font-size: 0.8em; margin-left:4px; margin-bottom:8px;">
      ì´ê±°ë¦¬ <span class="number">${formatDistance(totalDistance)}</span>
    </div>
  `;

  if (distanceOverlay) {
    distanceOverlay.setPosition(mousePosition);
    distanceOverlay.setContent(content);
  } else {
    distanceOverlay = new kakao.maps.CustomOverlay({
      map: map,
      content,
      position: mousePosition,
      xAnchor: 0,
      yAnchor: 0,
      zIndex: 3
    });
  }
}


// END: ê±°ë¦¬ í‘œì‹œìš© ì „ì—­ë³€ìˆ˜ ë° í•¨ìˆ˜

const trimCityProvince = str => str?.split(' ').slice(1).join(' ') || '';

function initializeMap(center) {
  map = new kakao.maps.Map(document.getElementById('map'), { center, level: 4, mapTypeId: kakao.maps.MapTypeId.HYBRID });
  geocoder = new kakao.maps.services.Geocoder();

kakao.maps.event.addListener(map, 'click', e => {
  if (markerInputOverlay) {
    markerInputOverlay.setMap(null);
    markerInputOverlay = null;
    return;
  }

  // âœ… ë§ˆì»¤ ìœ„ì¹˜ ì´ë™ ì¤‘ì´ë©´ ìƒˆ ìœ„ì¹˜ë¡œ ì„¤ì •
  if (movingPhotoMarker) {
    movingPhotoMarker.marker.setPosition(e.latLng);
    movingPhotoMarker.marker.setDraggable(false); // âœ… ì´ë™ í›„ ì ê¸ˆ
    movingPhotoMarker = null;
    return;
  }


  if (drawingMode) {
    currentPath.push(e.latLng);
    currentPolyline.setPath(currentPath);

    if (currentPath.length === 1 && !distanceOverlay) {
      const content = `
        <div class="dotOverlay distanceInfo" style="font-size: 0.8em; margin-left:4px; margin-bottom:8px;">
          ì´ê±°ë¦¬ <span class="number">0m</span>
        </div>
      `;
      distanceOverlay = new kakao.maps.CustomOverlay({
        map,
        content,
        position: e.latLng,
        xAnchor: 0,
        yAnchor: 1,
        zIndex: 3
      });
    }

if (movingPhotoMarker) {
  movingPhotoMarker.marker.setPosition(e.latLng);
  movingPhotoMarker.marker.setDraggable(false); // âœ… ë“œë˜ê·¸ ë¹„í™œì„±í™”
  movingPhotoMarker = null;
  return;
}

  }

  markers.forEach(m => m.iw.close());
  document.getElementById('latitude').value = e.latLng.getLat();
  document.getElementById('longitude').value = e.latLng.getLng();

  geocoder.coord2Address(e.latLng.getLng(), e.latLng.getLat(), (res, status) => {
    const el = document.getElementById('address-display');
    if (status === kakao.maps.services.Status.OK) {
      const legal = res[0].address?.address_name || 'ì£¼ì†Œ ì—†ìŒ';
      const roadFull = res[0].road_address?.address_name;
      const road = roadFull ? roadFull.split(' ').slice(1).join(' ') : '';
      el.innerText = road ? `${legal} / ${road}` : legal;
    } else {
      el.innerText = 'ì£¼ì†Œ ì—†ìŒ';
    }
  });
});


  // ê¸°ì¡´ rightclick ë¦¬ìŠ¤ë„ˆ ì¤‘ drawingMode ë¶„ê¸°ë¶€ë§Œ êµì²´
kakao.maps.event.addListener(map, 'rightclick', e => {
  if (drawingMode) {
    if (moveLine) { moveLine.setMap(null); moveLine = null; }
    if (distanceOverlay) { distanceOverlay.setMap(null); distanceOverlay = null; }

    drawingMode = false;
    document.getElementById('map').classList.remove('drawing-cursor');
  } else {
    showMarkerInput(e.latLng);
  }
});




  // ì£¼ì†Œ ê²€ìƒ‰
  document.getElementById('search-form').addEventListener('submit', e => {
    e.preventDefault();
    const keyword = document.getElementById('address-input').value;
    geocoder.addressSearch(keyword, (res, status) => {
      if (status === kakao.maps.services.Status.OK) {
        const pos = new kakao.maps.LatLng(res[0].y, res[0].x);
        map.setCenter(pos);

        // ì´ì „ì— ìƒì„±í•œ ê²€ìƒ‰ ë§ˆì»¤ê°€ ìˆìœ¼ë©´ ì œê±°
        if (searchMarker) {
          searchMarker.setMap(null);
        }
        // ìƒˆ ê²€ìƒ‰ ë§ˆì»¤ ìƒì„±
        searchMarker = new kakao.maps.Marker({
          map,
          position: pos
        });
        // ìš°í´ë¦­ìœ¼ë¡œ ê²€ìƒ‰ ë§ˆì»¤ ì‚­ì œ ê°€ëŠ¥
        kakao.maps.event.addListener(searchMarker, 'rightclick', () => {
          searchMarker.setMap(null);
          searchMarker = null;
        });
      } else {
        alert('ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      }
    });
  });
  // ì§€ë„ ìœ„ ë§ˆìš°ìŠ¤ ë¬´ë¸Œ ì‹œ ê±°ë¦¬ íˆ´íŒ ì—…ë°ì´íŠ¸
  kakao.maps.event.addListener(map, 'mousemove', updateDistance);

// Ctrl+C, Alt ë‹¨ì¶•í‚¤
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key.toLowerCase() === 'c') {
    e.preventDefault();
    copyCoordinates();
  }

  if (e.altKey) {
    e.preventDefault();
    if (drawingMode) {
      if (moveLine) moveLine.setMap(null);
      if (distanceOverlay) distanceOverlay.setMap(null);
      drawingMode = false;
      document.getElementById('map').classList.remove('drawing-cursor');
    } else {
      startDrawing();
    }
  }

  // âœ… Ctrl+S â†’ ë³´ì´ëŠ” ë§ˆì»¤/ì„ ë§Œ ë‚´ë³´ë‚´ê¸°
  if (e.ctrlKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    exportVisibleGPX(); // ğŸ”½ ì•„ë˜ í•¨ìˆ˜ ì •ì˜ í•„ìš”
  }
});



  // ë‚´ ìœ„ì¹˜ ë²„íŠ¼ (ğŸ“) ë³µêµ¬
  document.getElementById('myLocationBtn').onclick = () => {
    navigator.geolocation.getCurrentPosition(pos => {
      const ll = new kakao.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
      map.setCenter(ll);
      document.getElementById('latitude').value = pos.coords.latitude;
      document.getElementById('longitude').value = pos.coords.longitude;
    }, err => {
      alert('ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + err.message);
    });
  };
}
function showMarkerInput(latlng) {
  if (markerInputOverlay) markerInputOverlay.setMap(null);

  const container = document.createElement('div');
container.innerHTML = `
  <input type="text" placeholder="ë§ˆì»¤ ì´ë¦„" style="width:120px;padding:3px;" 
         lang="ko" autocomplete="off" autocapitalize="off" autocorrect="off" autofocus>
  <button style="margin-top:4px;">ì¶”ê°€</button>
  <button style="margin-top:4px;">ì·¨ì†Œ</button>`;


  container.style = 'background:white;padding:6px;border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,0.3);display:flex;flex-direction:column;gap:4px;';
  
  markerInputOverlay = new kakao.maps.CustomOverlay({ position: latlng, content: container, yAnchor: 1 });
  markerInputOverlay.setMap(map);

  container.addEventListener('mousedown', e => e.stopPropagation());

  const [input, addBtn, cancelBtn] = container.querySelectorAll('input, button');
  input.focus();
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addBtn.click();
    }
  });

  addBtn.onclick = () => {
    const text = input.value.trim() || 'ì„¤ëª… ì—†ìŒ';
    addMarker(latlng, text);
    markerInputOverlay.setMap(null);
  };
  cancelBtn.onclick = () => markerInputOverlay.setMap(null);
}

function addMarker(latlng, desc) {
  const marker = new kakao.maps.Marker({
    map,
    position: latlng,
    draggable: false
  });

  const div = document.createElement('div');
  div.style = 'position:relative; display:flex; align-items:center; justify-content:space-between; padding:5px;';
  div.innerHTML = `<span>${desc}</span><div style="cursor:pointer; font-weight:bold;">âœ–</div>`;
  const [label, btn] = div.querySelectorAll('span, div');

  const iw = new kakao.maps.InfoWindow({ content: div });

  kakao.maps.event.addListener(marker, 'click', () => iw.open(map, marker));
  kakao.maps.event.addListener(marker, 'rightclick', () => {
    showEditInput({ marker, iw, name: desc }, label);
  });
  btn.onclick = () => iw.close();

  let previousPosition = latlng;
  let holdTimer = null;

  kakao.maps.event.addListener(marker, 'mousedown', () => {
    map.setDraggable(false);
    holdTimer = setTimeout(() => {
      iw.close(); // âœ… í…ìŠ¤íŠ¸ì°½ ë‹«ê¸°
      marker.setDraggable(true);
      movingPhotoMarker = { marker, iw, name: desc };
    }, 1000);
  });

  ['mouseup', 'mouseout'].forEach(evt =>
    kakao.maps.event.addListener(marker, evt, () => {
      clearTimeout(holdTimer);
      map.setDraggable(true);
    })
  );

  kakao.maps.event.addListener(marker, 'dragend', () => {
    if (movingPhotoMarker && marker === movingPhotoMarker.marker) {
      previousPosition = marker.getPosition();
      marker.setDraggable(false);
      movingPhotoMarker = null;
    }
  });

  markers.push({ marker, iw, name: desc });
}

function addPhotoMarker(latlng, imgSrc, filename) {
  const marker = new kakao.maps.Marker({
    map,
    position: latlng,
    draggable: false
  });

  const div = document.createElement('div');
  div.style = 'position:relative; padding:5px;';
  div.innerHTML = `
    <div style="font-weight:bold; margin-bottom:5px;">${filename}</div>
    <div style="position:absolute; top:2px; right:2px; cursor:pointer;">âœ–</div>
    <img src="${imgSrc}" style="max-height:400px; display:block;">
  `;
  const [title, btn] = div.querySelectorAll('div');

  const iw = new kakao.maps.InfoWindow({ content: div });

  kakao.maps.event.addListener(marker, 'click', () => iw.open(map, marker));
  kakao.maps.event.addListener(marker, 'rightclick', () => {
    showEditInput({ marker, iw, name: filename }, title);
  });
  btn.onclick = () => iw.close();

  let previousPosition = latlng;
  let holdTimer = null;

  kakao.maps.event.addListener(marker, 'mousedown', () => {
    map.setDraggable(false);
    holdTimer = setTimeout(() => {
      iw.close(); // âœ… ì‚¬ì§„ì°½ ë‹«ê¸°
      marker.setDraggable(true);
      movingPhotoMarker = { marker, iw, name: filename };
    }, 1000);
  });

  ['mouseup', 'mouseout'].forEach(evt =>
    kakao.maps.event.addListener(marker, evt, () => {
      clearTimeout(holdTimer);
      map.setDraggable(true);
    })
  );

  kakao.maps.event.addListener(marker, 'dragend', () => {
    if (movingPhotoMarker && marker === movingPhotoMarker.marker) {
      previousPosition = marker.getPosition();
      marker.setDraggable(false);
      movingPhotoMarker = null;
    }
  });

  markers.push({ marker, iw, name: filename });
}

function showEditInput(markerObj, label) {
  if (markerInputOverlay) markerInputOverlay.setMap(null);

  const container = document.createElement('div');
  container.innerHTML = `
    <input type="text" value="${label.textContent}" style="width:120px;padding:3px;"
           lang="ko" autocomplete="off" autocapitalize="off" autocorrect="off" autofocus>
    <button style="margin-top:4px;">ìˆ˜ì •</button>
    <button style="margin-top:4px;">ì‚­ì œ</button>`;
  container.style = 'background:white;padding:6px;border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,0.3);display:flex;flex-direction:column;gap:4px;';

  markerInputOverlay = new kakao.maps.CustomOverlay({
    position: markerObj.marker.getPosition(),
    content: container,
    yAnchor: 1
  });
  markerInputOverlay.setMap(map);

  container.addEventListener('mousedown', e => e.stopPropagation());

  const [input, editBtn, deleteBtn] = container.querySelectorAll('input, button');

  input.focus();
  const val = input.value;
  input.value = '';
  input.value = val;

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      editBtn.click();
    }
  });

  editBtn.onclick = () => {
    const newName = input.value.trim() || 'ì„¤ëª… ì—†ìŒ';
    label.textContent = newName;
    markerObj.name = newName;

    // âœ… markers ë°°ì—´ ë‚´ë¶€ ê°ì²´ ì´ë¦„ë„ í•¨ê»˜ ìˆ˜ì •
    const found = markers.find(m => m.marker === markerObj.marker);
    if (found) found.name = newName;

    markerObj.iw.close();
    markerInputOverlay.setMap(null);
  };

  deleteBtn.onclick = () => {
    markerObj.marker.setMap(null);
    markerObj.iw.close();
    markerInputOverlay.setMap(null);
  };


}


function copyCoordinates() {
  const lat = document.getElementById('latitude').value;
  const lng = document.getElementById('longitude').value;
  navigator.clipboard.writeText(`${lat}, ${lng}`);
}

function startDrawing() {
  if (drawingMode) return;

  drawingMode = true;
  currentPath = [];

  currentPolyline = new kakao.maps.Polyline({
    map,
    path: currentPath,
    strokeWeight: 3,
    strokeColor: '#FF0000',
    strokeOpacity: 0.8
  });
  polylines.push(currentPolyline);

  // ê±°ë¦¬ ì˜¤ë²„ë ˆì´ ì´ˆê¸°í™”ëŠ” ì²« ì  í´ë¦­ ì‹œ ìƒì„±
  document.getElementById('map').classList.add('drawing-cursor');
}

const resetPolylines = () => {
  polylines.forEach(p => p.setMap(null));
  polylines = [];
  drawingMode = false;
  document.getElementById('map').classList.remove('drawing-cursor');
};

const resetAll = () => { markers.forEach(m => m.marker.setMap(null)); markers = []; resetPolylines(); };

function exportGPX() {
  const lastMarkerName = markers.at(-1)?.name?.trim() || 'data';
  const fname = prompt('íŒŒì¼ëª…', lastMarkerName);
  if (!fname) return;

  let gpx = '<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="KakaoMap">\n';

  polylines.forEach((pl, i) => {
    gpx += `<trk><name>path${i+1}</name><trkseg>\n` +
      pl.getPath().map(p => `<trkpt lat="${p.getLat()}" lon="${p.getLng()}"></trkpt>\n`).join('') +
      '</trkseg></trk>\n';
  });

  markers.forEach(m => {
    const p = m.marker.getPosition();
    gpx += `<wpt lat="${p.getLat()}" lon="${p.getLng()}"><name>${m.name || ''}</name></wpt>\n`;
  });

  gpx += '</gpx>';

  const blob = new Blob([gpx], { type: 'application/gpx+xml' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = fname + '.gpx';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


function exportVisibleGPX() {
  const bounds = map.getBounds();

  const visibleMarkers = markers.filter(m =>
    bounds.contain(m.marker.getPosition())
  );

  const visiblePolylines = polylines.filter(pl =>
    pl.getPath().some(p => bounds.contain(p))
  );

  const defaultName = visibleMarkers.at(-1)?.name?.trim() || 'visible_data';
  const fname = prompt('ë³´ì´ëŠ” ì˜ì—­ì˜ GPX ì €ì¥ íŒŒì¼ëª…', defaultName);
  if (!fname) return;

  let gpx = '<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="KakaoMap">\n';

  visiblePolylines.forEach((pl, i) => {
    gpx += `<trk><name>path${i+1}</name><trkseg>\n` +
      pl.getPath()
        .filter(p => bounds.contain(p))
        .map(p => `<trkpt lat="${p.getLat()}" lon="${p.getLng()}"></trkpt>\n`)
        .join('') +
      '</trkseg></trk>\n';
  });

  visibleMarkers.forEach(m => {
    const p = m.marker.getPosition();
    gpx += `<wpt lat="${p.getLat()}" lon="${p.getLng()}"><name>${m.name || ''}</name></wpt>\n`;
  });

  gpx += '</gpx>';

  const blob = new Blob([gpx], { type: 'application/gpx+xml' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = fname + '.gpx';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


// íŒŒì¼ ë“œë˜ê·¸ë¡œ ì‚¬ì§„/GPX ì—…ë¡œë“œ
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const files = Array.from(e.dataTransfer.files);
  if (!files.length) return;
  const bounds = new kakao.maps.LatLngBounds();

let photoWithoutGPSAction = null; // null | true | false

  files.forEach(file => {
    // 1) GPX íŠ¸ë™(seg) ê·¸ë¦¬ê¸°
    if (file.name.toLowerCase().endsWith('.gpx')) {
      const reader = new FileReader();
      reader.onload = ev => {
        const xml = new DOMParser().parseFromString(ev.target.result, 'application/xml');
const trks = xml.getElementsByTagName('trk');

Array.from(trks).forEach((trk, index) => {
  const nameTag = trk.getElementsByTagName('name')[0];
  const trackName = nameTag ? nameTag.textContent : `path${index + 1}`;
  const trksegs = trk.getElementsByTagName('trkseg');

  Array.from(trksegs).forEach(seg => {
    const pts = Array.from(seg.getElementsByTagName('trkpt')).map(pt => {
      const ll = new kakao.maps.LatLng(
        parseFloat(pt.getAttribute('lat')),
        parseFloat(pt.getAttribute('lon'))
      );
      bounds.extend(ll);
      return ll;
    });

    if (pts.length) {
      const poly = new kakao.maps.Polyline({
        map,
        path: pts,
        strokeWeight: 4,
        strokeColor: getRandomColor(),
        strokeOpacity: 0.9
      });

      const distance = poly.getLength();

      const formatDistance = d => {
        if (d <= 10) return `${d.toFixed(1)}m`;
        if (d < 1000) return `${Math.round(d)}m`;
        return `${(d / 1000).toFixed(2)}km`;
      };

      const overlay = new kakao.maps.CustomOverlay({
        content: `
          <div style="padding:5px 8px; background:white; border:1px solid #333; font-size:1.0em; border-radius:3px;">
            <b>${trackName}</b><br>ì´ê±°ë¦¬: ${formatDistance(distance)}
          </div>
        `,
        yAnchor: 1,
        zIndex: 4
      });

      kakao.maps.event.addListener(poly, 'mouseover', () => {
        const path = poly.getPath();
        const mid = path[Math.floor(path.length / 2)];
        overlay.setPosition(mid);
        overlay.setMap(map);
      });

      kakao.maps.event.addListener(poly, 'mouseout', () => {
        overlay.setMap(null);
      });

      polylines.push(poly);
    }
  });
});

        Array.from(xml.getElementsByTagName('wpt')).forEach(wpt => {
          const ll = new kakao.maps.LatLng(
            parseFloat(wpt.getAttribute('lat')),
            parseFloat(wpt.getAttribute('lon'))
          );
          bounds.extend(ll);
          addMarker(ll, wpt.getElementsByTagName('name')[0]?.textContent || 'ì„¤ëª… ì—†ìŒ');
        });
        if (!bounds.isEmpty()) map.setBounds(bounds);
      };
      reader.readAsText(file);

    // 2) ì´ë¯¸ì§€(EXIF) â†’ ë§ˆì»¤
    } else if (file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = ev => {
        const img = new Image();
        img.onload = () => {
          EXIF.getData(img, function() {
            const lat = EXIF.getTag(this, 'GPSLatitude');
            const lon = EXIF.getTag(this, 'GPSLongitude');
            const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
            const lonRef = EXIF.getTag(this, 'GPSLongitudeRef');
            if (lat && lon && latRef && lonRef) {
              const conv = (dms, ref) =>
                (dms[0] + dms[1]/60 + dms[2]/3600) * (ref === 'S' || ref === 'W' ? -1 : 1);
              const ll = new kakao.maps.LatLng(
                conv(lat, latRef),
                conv(lon, lonRef)
              );
              bounds.extend(ll);
              addPhotoMarker(ll, ev.target.result, file.name.replace(/\.[^/.]+$/, ''));
              if (!bounds.isEmpty()) map.setBounds(bounds);
            }
else {
  if (photoWithoutGPSAction === null) {
    photoWithoutGPSAction = confirm(`"${file.name}" ì‚¬ì§„ì— ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.\nì§€ë„ ì¤‘ì‹¬ì— ë§ˆì»¤ë¥¼ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì´ ì„ íƒì€ ì´ë²ˆì— ì˜¬ë¦¬ëŠ” ëª¨ë“  ì‚¬ì§„ì— ì ìš©ë©ë‹ˆë‹¤)`);
  }

  if (photoWithoutGPSAction) {
    const center = map.getCenter();
    addPhotoMarker(center, ev.target.result, file.name.replace(/\.[^/.]+$/, ''));
    map.panTo(center);

    const addedMarker = markers.at(-1);
    if (addedMarker) {
      addedMarker.marker.setDraggable(true);
      movingPhotoMarker = addedMarker;
    }
  }
}

          });
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
});

window.onload = () => {
  navigator.geolocation.getCurrentPosition(
    pos => initializeMap(new kakao.maps.LatLng(pos.coords.latitude, pos.coords.longitude)),
    () => initializeMap(new kakao.maps.LatLng(37.5665, 126.9780))
  );
};

function downloadCompressedImage(imgSrc, filename, maxWidth = 1600, quality = 0.98) {
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    const scale = maxWidth / img.width;
    const canvas = document.createElement('canvas');
    canvas.width = maxWidth;
    canvas.height = img.height * scale;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }, 'image/jpeg', quality);
  };
  img.src = imgSrc;
}

function downloadAllPhotos() {
  markers.forEach(m => {
    const iwContent = m.iw.getContent();
    const img = iwContent.querySelector('img');
    if (!img || !img.src.startsWith('data:image')) return;

    const latlng = m.marker.getPosition();
    const lat = latlng.getLat();
    const lng = latlng.getLng();

    // 1. ì´ë¯¸ì§€ ë¡œë“œ
    const image = new Image();
    image.onload = () => {
      // 2. í¬ê¸° ì¤„ì´ê¸°
      const maxWidth = 1600;
      const scale = maxWidth / image.width;
      const canvas = document.createElement('canvas');
      canvas.width = maxWidth;
      canvas.height = image.height * scale;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

      // 3. JPEGë¡œ export
      canvas.toBlob(blob => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const resizedDataUrl = reader.result;

          // 4. EXIF ì‚½ì…
          const toDMS = val => {
            const abs = Math.abs(val);
            const deg = Math.floor(abs);
            const min = Math.floor((abs - deg) * 60);
            const sec = ((abs - deg - min / 60) * 3600);
            return [[deg, 1], [min, 1], [Math.round(sec * 100), 100]];
          };

          const exifObj = { "GPS": {} };
          exifObj["GPS"][piexif.GPSIFD.GPSLatitudeRef] = lat >= 0 ? "N" : "S";
          exifObj["GPS"][piexif.GPSIFD.GPSLatitude] = toDMS(lat);
          exifObj["GPS"][piexif.GPSIFD.GPSLongitudeRef] = lng >= 0 ? "E" : "W";
          exifObj["GPS"][piexif.GPSIFD.GPSLongitude] = toDMS(lng);
          const exifBytes = piexif.dump(exifObj);
          const finalDataUrl = piexif.insert(exifBytes, resizedDataUrl);

          // 5. ë‹¤ìš´ë¡œë“œ
          const a = document.createElement('a');
          a.href = finalDataUrl;
          a.download = (m.name || 'image') + '.jpg';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        };
        reader.readAsDataURL(blob);
      }, 'image/jpeg', 0.98); // ì••ì¶• ë¹„ìœ¨
    };
    image.src = img.src;
  });
}


</script>
</body>
</html>
